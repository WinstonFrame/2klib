/* Файл:   example.rcp
 * Проект: 2KLIB. Версия 2.04.
 *         Библиотека классов параллельного программирования для C++.
 * Примеры использования библиотеки классов 2KLIB
 * Гурин С.В. Томский политехнический университет, каф. электрических станций
 * Borland C++ 3.1, Rcc 3.3, Multi-Edit 7.0
 *
 * В этом файле записаны тексты всех примеров. Каждый пример имеет следующий
 * формат:
 *
 *    // заголовок примера
 *   # ifdef имя_примера
 *     текст примера
 *   # endif
 *
 * Имя примера начинается буквой N, затем следует цифра номера примера
 * и затем необязательная буква, обозначающая вариант примера.
 *
 * Для компиляции примера программы введите командную строку:
 *     rcc -Di @                 где: i - номер примера, например:
 *
 *     rcc -DN5 @                для примера N5
 *     rcc -DN9a @               для примера N9a
 *
 * Замечание!!!. Данная версия библиотеки спроектирована только для
 *               компилятора Borland C++ версии 3.1.. Работа с другими
 *               компиляторами не гарантируется.
 */

 // Минимальная программа
# ifdef N1

# include <iostream.h>
# include "2k.h"

void ТСценарий::тело_процесса(void)
{ cout << "Пример 1. Минимальная программа.\n"
          "Здравствуй, мир!\n";
}

# endif

 // Создание параллельного процесса
# ifdef N2

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ public:
    void тело_процесса(void)
    { cout << "Параллельный процесс\n";
    }
};

void ТСценарий::тело_процесса(void)
{ cout << "Пример 2. Создание параллельного процесса.\n"
          "Сценарий\n";
  new Т;
}

# endif

 // Создание массива параллельных процессов
# ifdef N3

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ private:
    int индекс;
  public:
    Т(int а_индекс)
    { индекс = а_индекс;
    }
    void тело_процесса(void)
    { cout << "Параллельный процесс " << индекс << '\n';
    }
};

void ТСценарий::тело_процесса(void)
{ cout << "Пример 3. Создание массива параллельных процессов.\n"
          "Сценарий\n";
  for (int i = 1; i <= 3; ++i)
    new Т(i);
}

# endif

 // Приостановка и завершение динамического параллельного процесса.
# ifdef N4

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ public:
    void тело_процесса(void);
    ~Т()
    { cout << "Уничтожение процесса Т\n";
    }
};

void Т::тело_процесса(void)
{ int i = 0;
  for (;;)
  { cout << "Параллельный процесс. Итерация: " << ++i << '\n';
    пауза(100);
  }
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 4. Приостановка и завершение динамического "
          "параллельного процесса.\n"
          "Сценарий\n";
  Т* процесс = new Т;
  пауза(1000);
  delete процесс;
}

# endif

 // Контроль существования процесса
# ifdef N4a

# include <iostream.h>
# include "2k.h"

простой_процесс(Т)
{ cout << "Процесс Т начат\n";
  пауза(1000);
  cout << "Процесс Т завершен\n";
}

void контроль_процесса(Т* а_процесс, int а_идентификатор)
{ if (существует(а_процесс, а_идентификатор))
    cout << "Процесс Т существует\n";
  else
    cout << "Процесс Т не существует\n";
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 4a. Контроль существования процесса.\n";
  Т* процесс = new Т;
  int идентификатор_Т = процесс->идентификатор();
  пауза(500);
  контроль_процесса(процесс, идентификатор_Т);
  пауза(1000);
  контроль_процесса(процесс, идентификатор_Т);
}

# endif

 // Создание статического параллельного процесса. Часы реального времени.
# ifdef N5

# include <iostream.h>
# include <iomanip.h>
# include "2k.h"

class ТЧасы : public ТПроцесс
{ public:
    void тело_процесса(void);
};

void ТЧасы::тело_процесса(void)
{ ТВремя* время;
  for (;;)
  { время = текущее_время();
    cout << setfill('0') << setw(2) << время->час     << ":"
         << setfill('0') << setw(2) << время->минута  << ":"
         << setfill('0') << setw(2) << время->секунда << '\n';
    пауза(1000);
  }
}

static ТЧасы часы;

void ТСценарий::тело_процесса(void)
{ cout << "Пример 5. Создание статического параллельного процесса - часов.\n"
          "Время работы программы - 10 секунд.\n"
          "Сценарий\n";
  пауза(10000);
}

# endif

 // Создание статических параллельных процессов с инициализацией
# ifdef N5a

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ private:
    int i;
  public:
    Т(int арг) { i = арг; }
    void тело_процесса(void);
};

void Т::тело_процесса(void)
{ for (;;)
  { cout << i << '\n';
    пауза(1000);
  }
}

static Т процесс_1(10);
static Т процесс_2(20);

void ТСценарий::тело_процесса(void)
{ cout << "Пример 5a. Создание инициализированных статических параллельных процессов.\n"
          "Время работы программы - 5 секунд.\n"
          "Сценарий\n";
  пауза(5000);
}

# endif

 // Передача и прием сообщения по каналу
# ifdef N6

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ public:
    ТКанал<int> канал;
    void тело_процесса(void);
};

void Т::тело_процесса(void)
{ int i;
  cout << "Попытка приема сообщения\n";
  канал >> i;
  cout << "Принято сообщение " << i << " от процесса "
       << (void*)канал.корреспондент() << '\n';
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 6. Передача и прием сообщения по каналу.\n";
  Т* процесс = new Т;
  пауза(1000);
  int i = 123;
  процесс->канал << i;
  cout << "Сообщение " << i << " отправил процесс " << (void*)this << '\n';
}

# endif

 // Передача и прием сообщения по каналу с таймаутом
# ifdef N6a

# include <iostream.h>
# include "2k.h"

class Т : public ТПроцесс
{ public:
    ТКанал<int> канал;
    Т(void)
    { канал.таймаут(1000);
    }
    void тело_процесса(void);
};

void Т::тело_процесса(void)
{ int i;
  for (;;)
  { if (канал >> i) cout << "Принято сообщение " << i << '\n';
    else            cout << "Таймаут\n";
  }
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 6a. Передача и прием сообщения по каналу с таймаутом.\n";
  Т* процесс = new Т;
  int i;
  процесс->канал << (i = 1);
  cout << "Передано сообщение " << i << '\n';
  пауза(500);
  процесс->канал << (i = 2);
  cout << "Передано сообщение " << i << '\n';
  пауза(2000);
  delete процесс;
}

# endif

 // Передача сообщения в начало и конец канала
# ifdef N6b

# include <iostream.h>
# include "2k.h"

ТКанал<int> канал;

простой_процесс(Т)
{ int i;
  for (;;)
  { канал >> i;
    cout  << "Принято сообщение " << i << '\n';
  }
}
static Т приемник;

// Запрет выдачи предупреждения о преобразовании константы во временный
// объект при передаче в канал
# pragma warn -lvc

void ТСценарий::тело_процесса(void)
{ cout << "Пример 6b. Передача сообщения в начало и конец канала.\n";
  канал <<  1;
  канал <<  2;
  канал <<= 3;
  канал <<= 4;
  пауза(100);
}

# endif

 // Передача сигнала
# ifdef N6c

# include <iostream.h>
# include "2k.h"

ТКанал<ТСигнал> канал;

простой_процесс(Т)
{ for (;;)
  { канал >> сигнал;
    cout  << "Итерация процесса Т, запуск по сигналу.\n";
  }
}

static Т приемник;

void ТСценарий::тело_процесса(void)
{ cout << "Пример 6c. Передача сигнала по каналу.\n";
  канал << сигнал;
  пауза(100);
  канал << сигнал;
  пауза(100);
}

# endif

 // Недетерминированный прием сообщений по каналу с таймаутом
# ifdef N7

# include <iostream.h>
# include <string.h>
# include "2k.h"

enum   ТТег              { целое, строка      };
struct ТКонтейнер_Целого { int  значение;     };
struct ТКонтейнер_Строки { char значение[10]; };

ТКанал<ТТег>              канал_тега;
ТКанал<ТКонтейнер_Целого> канал_целых;
ТКанал<ТКонтейнер_Строки> канал_строк;

простой_процесс(ТГенератор_Целых)
{ ТТег тег = целое;
  ТКонтейнер_Целого контейнер;
  контейнер.значение = 123;
  for (;;)
  { канал_тега  << тег;
    канал_целых << контейнер;
    пауза(случайное_число(200, 600));
  }
}

static ТГенератор_Целых генератор_целых;

простой_процесс(ТГенератор_Строк)
{ ТТег тег = строка;
  ТКонтейнер_Строки контейнер;
  strcpy(контейнер.значение, "ABCDEF");
  for (;;)
  { канал_тега  << тег;
    канал_строк << контейнер;
    пауза(случайное_число(200, 600));
  }
}

static ТГенератор_Строк генератор_строк;

void ТСценарий::тело_процесса(void)
{ cout << "Пример 7. Недетерминированный прием сообщений по "
          "каналу с таймаутом.\n"
          "Время работы программы - 10сек\n";
  ТТег тег;
  ТКонтейнер_Целого контейнер_целого;
  ТКонтейнер_Строки контейнер_строки;
  канал_тега.таймаут(300);
  ТСистемное_Время время_завершения = системное_время() + 10000;
  while (время_завершения > системное_время())
  { if (канал_тега >> тег)
    { switch (тег)
      { case целое:
          канал_целых >> контейнер_целого;
          cout << "Принято целое " << контейнер_целого.значение << '\n';
          break;
        case строка:
          канал_строк >> контейнер_строки;
          cout << "Принята строка " << контейнер_строки.значение << '\n';
          break;
      }
    }
    else cout << "Таймаут\n";
  }
}

# endif

 // Синхронизации процессов на базе рандеву
# ifdef N8

# include <iostream.h>
# include "2k.h"

ТРандеву<int> рандеву;

простой_процесс(ТПроизводитель)
{ int i = 0;
  for (;;)
  { пауза(случайное_число(1000, 6000));
    cout << "Готов производитель\n";
    рандеву << ++i;
    cout << "Передано значение " << i << '\n';
  }
}

простой_процесс(ТПотребитель)
{ int i;
  for (;;)
  { пауза(3000);
    cout << "Готов потребитель\n";
    рандеву >> i;
    cout << "Принято значение: " << i << '\n';
  }
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 8. Синхронизации процессов на базе рандеву.\n"
          "Время работы программы - 10сек\n";
  ТПроизводитель* производитель = new ТПроизводитель;
  ТПотребитель*   потребитель   = new ТПотребитель;
  пауза(10000);
  delete потребитель;
  delete производитель;
}

# endif

 // Синхронизации процессов на базе рандеву с таймаутом
# ifdef N8a

# include <iostream.h>
# include "2k.h"

ТРандеву<int> рандеву;

простой_процесс(ТПроизводитель)
{ int i = 0;
  for (;;)
  { пауза(случайное_число(1000, 5000));
    cout << "Готов производитель\n";
    if (рандеву << ++i) cout << "Передано значение " << i << '\n';
    else                cout << "Таймаут производителя\n";
  }
}

простой_процесс(ТПотребитель)
{ int i;
  for (;;)
  { пауза(1500);
    cout << "Готов потребитель\n";
    if (рандеву >> i) cout << "Принято значение: " << i << '\n';
    else              cout << "Таймаут потребителя\n";
  }
}

void ТСценарий::тело_процесса(void)
{ cout << "Пример 8a. Синхронизации процессов на базе рандеву с таймаутом.\n"
          "Время работы программы - 20сек\n";
  рандеву.таймаут(2000);
  ТПроизводитель* производитель = new ТПроизводитель;
  ТПотребитель*   потребитель   = new ТПотребитель;
  пауза(20000);
  delete потребитель;
  delete производитель;
}

# endif

 // Работа с клавиатурой
# ifdef N9

# include <iostream.h>
# include "2kkey.h"

ТКанал<ТСобытие> канал;

void ТСценарий::тело_процесса(void)
{ cout << "Пример 9. Работа с клавиатурой: получение кодов клавиш.\n"
          "Нажимайте различные клавиши. Для завершения нажмите Esc...\n";
  ТСобытие клавиша;
  клавиатура.соединить(канал);
  do
  { канал >> клавиша;
    cout << "Код " << КОД_КЛАВИШИ(клавиша)
         << ", расширенный код " << РАСШИРЕННЫЙ_КОД(клавиша) << '\n';
  } while (клавиша != ESC);
}

# endif

 // Работа с клавиатурой и каналами. Процессы с виртуальными функциями
# ifdef N9a

# include <iostream.h>
# include "2kkey.h"

class ТБазовый : public ТПроцесс
{ public:
    ТКанал<int> вход;
    void тело_процесса(void);
    virtual void действие(int арг) = 0; // чистая виртуальная функция
};

void ТБазовый::тело_процесса(void)
{ int i;
  for (;;)
  { вход >> i;
    действие(i);
  }
}

class Т1 : public ТБазовый
{ public:
    void действие(int арг) { cout << "Процесс 1. Аргумент " << арг << '\n'; }
};

class Т2 : public ТБазовый
{ public:
    void действие(int арг) { cout << "Процесс 2. Аргумент " << арг << '\n'; }
};

static Т1 процесс_1;
static Т2 процесс_2;

# pragma warn -lvc

void ТСценарий::тело_процесса(void)
{ cout << "Пример 9a. Работа с клавиатурой  и каналами.\n"
          "           Процессы с виртуальными функциями\n"
          "Нажимайте клавиши 1 или 2. Для завершения нажмите Esc...\n";
  ТКанал<ТСобытие> канал;
  ТСобытие клавиша;
  клавиатура.соединить(канал);
  do
  { канал >> клавиша;
    switch (клавиша)
    { case '1': процесс_1.вход << 100; break;
      case '2': процесс_2.вход << 200; break;
    }
  } while (клавиша != ESC);
}

# endif

 // Определение конструктора и деструктора сценария, получение
  // параметров командной строки DOS
# ifdef N10

# include <dos.h>
# include <iostream.h>
# include "2k.h"

void ТСценарий::тело_процесса(void)
{ cout << "Пример 10. Определение конструктора и деструктора сценария.\n"
          "Параметры командной строки DOS:\n"
          "  число аргументов: " << _argc
       << "\n  аргументы:\n";
  for (int i = 0; i < _argc; ++i)
  { cout << "    " << _argv[i] << endl;
  }
}

ТСценарий::ТСценарий(int а_размер_стека)
: ТПроцесс(а_размер_стека, "Сценарий")
{ cout << "Конструктор сценария\n";
}

ТСценарий::~ТСценарий()
{ cout << "Деструктор сценария\n";
}

# endif

 // Определение собственной функции main
# ifdef N10a

# include <alloc.h>
# include <iostream.h>
# include "2k.h"

void ТСценарий::тело_процесса(void)
{ cout << "Пример 10a. Определение собственной функции main.\n";
}

extern int main()
{ ULONG объем_памяти = (ULONG)coreleft();
  старт_сценария(8000, // размер стека сценария
                 1);   // вызывать ли драйвер системного таймера
                       // 18 раз в секунду?
  if (объем_памяти != coreleft())
    программная_ошибка("Потеряны блоки памяти");
  return 0;
}

# endif
