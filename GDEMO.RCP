/* Файл:   gdemo.rcp
 * Проект: 2KLIB. Версия 2.04.
 *         Библиотека классов параллельного программирования для C++.
 * Демо-пример использования библиотеки классов 2KLIB
 * Работа с графикой
 * Гурин С.В. Томский политехнический университет, каф. электрических станций
 * Borland C++ 3.1, Rcc 3.3, Multi-Edit 7.0
 *
 * Для компиляции демо - программы введите командную строку:
 *     rcc @gdemo
 *
 * Замечание!!!. Данная версия библиотеки спроектирована только для
 *               компилятора Borland C++ версии 3.1.. Работа с другими
 *               компиляторами не гарантируется.
 */


# include <graphics.h>
# include <stdio.h>
# include "2kkey.h"
# include "note.h"

static int махх, маху;

простой_процесс(ТЗвезда)
{ int х = 1;
  int у = 1;
  int цвет = случайное_число(1, 15);
  for (;;)
  { пауза(случайное_число(500, 2000));
    putpixel(х, у, 0);
    putpixel(х + 1, у, 0);
    putpixel(х, у + 1, 0);
    putpixel(х + 1, у + 1, 0);
    х = случайное_число(1, махх);
    у = случайное_число(1, маху);
    putpixel(х, у, цвет);
    putpixel(х + 1, у, цвет);
    putpixel(х, у + 1, цвет);
    putpixel(х + 1, у + 1, цвет);
  }
}

static ТЗвезда звезда[200];

простой_процесс(ТКомета)
{ int dx, dy, х, у, цвет, скорость;
  for (;;)
  { dx = случайное_число(-1, 1);
    dy = случайное_число(-1, 1);
    if (!dx) dx = 1;
    if (!dy) dy = 1;
    х  = случайное_число(5, махх - 5);
    у  = случайное_число(5, маху - 5);
    скорость = случайное_число(3, 25);
    цвет     = случайное_число(10, 15);
    пауза(случайное_число(2000, 5000));
    for (;;)
    { setfillstyle(SOLID_FILL, 0);
      bar(х, у, х + 8, у + 8);
      х += dx;
      if (х == 1 || х == махх - 8) break;
      у += dy;
      if (у == 1 || у == маху - 8) break;
      setfillstyle(SOLID_FILL, цвет);
      bar(х, у, х + 8, у + 8);
      пауза(скорость);
    }
  }
}

static ТКомета комета[10];

простой_процесс(ТМелодия)
{ static int нота[] =
  { РЕ, МИ, ФА, МИ,
    ФА, РЕ, ДО_ДИЕЗ, РЕ,
    МИ, ФА, СОЛЬ, МИ,
    ФА, МИ, МИ, РЕ,
    ДО_ДИЕЗ, ЛЯ / 2, ДО_ДИЕЗ, МИ,
    ЛЯ, СОЛЬ, ФА, МИ,
    0
  };
  for (int i = 0, делитель = 8; ; ++i)
  { if (нота[i] == 0)
    { i = 0;
      делитель = 1 << случайное_число(0, 3);
    }
    звук(нота[i] * 4 / делитель, 400);
    контроль_стека();
  }
}

static ТМелодия мелодия;

static volatile int число_шаров = 0;

простой_процесс(ТШар)
{ int цвет = случайное_число(9, 15);
  int х = случайное_число(20, махх - 20);
  int скорость = случайное_число(3, 30);
  int радиус = случайное_число(10, 80);
  число_шаров++;
  for (int у = маху + 20; у > 1; --у)
  { setcolor(0);
    circle(х, у, радиус);
    setcolor(цвет);
    circle(х, у - 1, радиус);
    пауза(скорость);
  }
  setcolor(0);
  circle(х, у, радиус);
  число_шаров--;
}

void ТСценарий::тело_процесса(void)
{ ТКанал<ТСобытие> канал;
  ТСобытие клавиша;
  канал.таймаут(10000);
  клавиатура.соединить(канал);

  int драйвер = DETECT, мода, код_ошибки;
  initgraph(&драйвер, &мода, "");
  код_ошибки = graphresult();
  if (код_ошибки != grOk)
    программная_ошибка(grapherrormsg(код_ошибки));
  settextstyle(DEFAULT_FONT, HORIZ_DIR, 2);
  outtextxy(1, 1, "Демо - пример работы с графикой");
  outtextxy(1, 18, "Для завершения нажмите Esc...");
  rectangle(1, 39, getmaxx() - 2, getmaxy() - 4);
  setviewport(2, 40, getmaxx() - 3, getmaxy() - 5, 1);
  махх = getmaxx() - 3;
  маху = getmaxy() - 45;
  for (;;)
  { канал >> клавиша;
    if (клавиша == ESC) break;
    if (число_шаров < 20) new ТШар;
    контроль_стека();
  }
  if (число_шаров)
  { setviewport(1, 1, getmaxx(), getmaxy(), 0);
    setfillstyle(SOLID_FILL, 0);
    bar(1, 18, getmaxx(), 36);
    setcolor(YELLOW);
    outtextxy(1, 18, "Завершение динамических процессов");
    setviewport(2, 40, getmaxx() - 3, getmaxy() - 5, 1);
    while (число_шаров) пауза(100);
  }
  звук(0);
  closegraph();
}
