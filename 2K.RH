/* Файл:   2k.rh
 * Проект: 2KLIB. Версия 2.04.
 *         Библиотека классов параллельного программирования для C++.
 * Определения конструкций параллельного программирования.
 * Гурин С.В. Томский политехнический университет, каф. электрических станций
 * Borland C++ 3.1, Rcc 3.0, Multi-Edit 7.0
 *
 * Внимание!!!
 * Программа зависит от типа компилятора. Разработка была выполнена с
 * использованием компилятора Borland C++ 3.1 и только для large-модели
 * памяти. Работа с другим компилятором и в другой модели памяти не
 * гарантируется.
 */

# ifndef __2k_rh
# define __2k_rh

# ifndef __LARGE__
  # error Use large memory model only
# endif

# if __BCPLUSPLUS__ != 0x310
  # error Use Borland C++ 3.1 only
# endif

# if __BORLANDC__ != 0x410
  # error Use Borland C++ 3.1 only
# endif

# include <setjmp.h>

typedef unsigned int  UINT;
typedef unsigned long ULONG;
typedef int   BOOL;              // используется для логических значений
typedef int   ТСигнал;           // используется для передачи сигналов
typedef ULONG ТСистемное_Время;  // в миллисекундах
typedef struct
        { int секунда, минута, час;
        } ТВремя;

const UINT СИГНАТУРА_ПРОЦЕССА = 0xD365;

class ТПроцесс
{ friend class ТОчередь;
  friend class ТОчередь_Сообщений;
  friend class ТКонверт_Рандеву;
  friend BOOL  существует(ТПроцесс*, int);
  friend char* имя_активного_процесса(void);
  friend void  пауза(void);
  friend void  пауза(ТСистемное_Время);
  friend void  контроль_корректности_стека(char*, int);
  friend void  старт_сценария(int, BOOL);

  private:
    UINT             сигнатура_процесса;
    int              идентификатор_процесса;
    char*            имя_процесса;
    UINT*            стек_процесса;
    UINT*            вершина_стека_процесса;
    UINT*            граница_стека_процесса;
    jmp_buf          контекст_процесса;
    BOOL             активность_процесса;
    BOOL             стационарность_процесса;
    ТПроцесс*        следующий;
    ТПроцесс*        предыдущий;
    ТОчередь*        очередь_процесса;
    ТСистемное_Время время_ожидания_процесса;
    void             создание_контекста(void);
    static void      обработчик_завершения(void);
    static void      диспетчер_процессов(void);

    static ТПроцесс* первый;
    static ТПроцесс* последний;
    static int       текущий_идентификатор;

  public:
    ТПроцесс(int а_размер_стека = 1024, const char* а_имя = 0);
    virtual ~ТПроцесс();
    virtual void тело_процесса(void) = 0;
    int идентификатор(void) const { return идентификатор_процесса; }
};

// макро для лаконичного определения типа и тела процесса в том случае,
// когда процесс не содержит явного конструктора, деструктора и членов
# define простой_процесс(Тип) class Тип : public ТПроцесс \
                              { public: void тело_процесса(void); \
                                        Тип(void) : ТПроцесс(1024, #Тип) {} \
                              }; void Тип::тело_процесса(void)

class ТСценарий : public ТПроцесс
{ public:
    ТСценарий(int а_размер_стека);
    ~ТСценарий();
    void тело_процесса(void);
};

class ТКонтекст_Сообщения
{ public:
    ТКонтекст_Сообщения* следующий;
    ТПроцесс*            процесс;
};

template<class Т>
class ТКонтейнер_Сообщения : public ТКонтекст_Сообщения
{ public:
    Т сообщение;
    ТКонтейнер_Сообщения(Т& а_сообщение) { сообщение = а_сообщение; }
};

class ТОчередь_Сообщений
{ protected:
    ТКонтекст_Сообщения* первый;
    ТКонтекст_Сообщения* последний;
    ТПроцесс*            процесс_получатель;
    ТПроцесс*            процесс_отправитель;
    ТСистемное_Время     время_таймаута;
    BOOL                 флаг_таймаута;

    void добавить_в_конец(ТКонтекст_Сообщения* а_элемент);
    void добавить_в_начало(ТКонтекст_Сообщения* а_элемент);
    ТКонтекст_Сообщения* получить(void);

  public:
    ТОчередь_Сообщений(void);
    ~ТОчередь_Сообщений(void);
};

template<class Т>
class ТКанал : private ТОчередь_Сообщений
{ public:
    void operator << (Т& а_сообщение) // передача в конец очереди канала
    { добавить_в_конец(new ТКонтейнер_Сообщения<Т>(а_сообщение));
    }
    void operator <<= (Т& а_сообщение) // передача в начало очереди канала
    { добавить_в_начало(new ТКонтейнер_Сообщения<Т>(а_сообщение));
    }
    BOOL operator >> (Т& а_значение)  // прием из канала
    { ТКонтейнер_Сообщения<Т>* t = (ТКонтейнер_Сообщения<Т>*)получить();
      if (t)
      { а_значение = t->сообщение;
        delete t;
        return 1;
      }
      return 0;
    }
    ТПроцесс* корреспондент(void) const    { return процесс_отправитель; }
    void таймаут(ТСистемное_Время а_время) { время_таймаута = а_время;   }
    ТСистемное_Время таймаут(void) const   { return время_таймаута;      }
    BOOL пуст(void) const                  { return !первый;             }
};

class ТКонверт_Рандеву
{ private:
    ТПроцесс* процесс_получатель;
    ТПроцесс* процесс_отправитель;
    BOOL флаг_таймаута;

  protected:
    ТСистемное_Время время_таймаута;

  public:
    ТКонверт_Рандеву(void)
    { процесс_отправитель = процесс_получатель = 0;
      время_таймаута = 0;
    }
    BOOL передать(void);
    BOOL принять(void);
};

template<class Т>
class ТРандеву : private ТКонверт_Рандеву
{ private:
    Т данные;

  public:
    BOOL operator << (Т& а_данные)  // передача в точку рандеву
    { данные = а_данные;
      return передать();
    }
    BOOL operator >> (Т& а_данные)  // прием из точки рандеву
    { if (принять())
      { а_данные = данные;
        return 1;
      }
      return 0;
    }
    void таймаут(ТСистемное_Время а_время) { время_таймаута = а_время; }
    ТСистемное_Время таймаут(void) const   { return время_таймаута;    }
};

// Переменные, доступные в прикладной программе
volatile extern ТСистемное_Время текущее_время_программы;
extern ТПроцесс*                 активный_процесс;
extern ТСистемное_Время          время_старта_программы;
extern ТСигнал                   сигнал;
extern int                       код_системной_ошибки;

// Пользовательские функции и различного назначения.
extern ТСистемное_Время системное_время(void); // в миллисекундах от старта
extern ТВремя* текущее_время(void);
extern char* имя_активного_процесса(void);
extern void пауза(void);
extern void пауза(ТСистемное_Время а_время);
extern int  случайное_число(int а_минимум, int а_максимум);
extern void звук(int а_частота, int а_длительность = 0);
extern void аварийное_завершение_программы(void);
extern void контроль_корректности_памяти(char* а_файл, int а_строка);
extern void контроль_корректности_стека(char* а_файл, int а_строка);
extern void программная_ошибка(const char* а_сообщение    = 0,
                               const char* а_имя_файла    = 0,
                               int         а_номер_строки = 0);
extern void старт_сценария(int а_размер_стека, BOOL а_вызов_системного_таймера);

inline BOOL существует(ТПроцесс* а_процесс, int а_идентификатор)
{ return ( (а_процесс->сигнатура_процесса == СИГНАТУРА_ПРОЦЕССА)  &&
           (а_процесс->идентификатор_процесса == а_идентификатор) );
}

inline void delay(unsigned а_миллисекунд)
{ пауза((ТСистемное_Время)а_миллисекунд);
}

inline void sleep(unsigned а_секунд)
{ пауза((ТСистемное_Время)а_секунд * 1000L);
}

// макро обработки ошибок
# ifdef NDEBUG
  # define утверждение(expr) ((void)0)
  # define недопустимая_точка_программы() ((void)0)
  # define контроль_памяти() ((void)0)
  # define контроль_стека() ((void)0)
# else
  # define утверждение(expr) \
             if (!(expr)) программная_ошибка(0, __FILE__, __LINE__)
  # define недопустимая_точка_программы() \
             программная_ошибка(0, __FILE__, __LINE__)
  # define контроль_памяти() контроль_корректности_памяти(__FILE__, __LINE__)
  # define контроль_стека()  контроль_корректности_стека(__FILE__, __LINE__)
# endif

# endif
